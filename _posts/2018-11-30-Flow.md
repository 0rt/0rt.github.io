---
layout: article
title: 校园网流量查询脚本
mathjax: true
mermaid: true
chart: true
toc: true
mode: immersive
tags : Python 网络
key: flow
header:
  theme: dark
article_header:
  type: overlay
  theme: dark
  background_color: '#ffffff'
  background_image:
    gradient: 'linear-gradient(0deg, rgba(0, 0, 0 , .2), rgba(0, 0, 0, .2))'
    src: https://img.vim-cn.com/9b/30747e8884b52933efc1b8e83a226dfa7a4744.jpg
---

因为校园网流量有限，所以需要经常查流量，所以就写了一个Python脚本，还发现了一些有趣的问题
<!--more-->

---

偶尔可以搜索到学长写的一些脚本，比如说:

[西电教学评估速选器](https://github.com/snokier/xd-teaching-evaluator)

[xidian-scripts](xidian-scripts)

[pytho简单爬虫_模拟登陆西电流量查询](https://www.bbsmax.com/A/o75Njnej5W/)

然而他们都已经 **失效了**，同时也存在一些问题，这里就更新下使之能够适用于当下，并且在学长的基础做些改进

- 支持命令行运行，无需读写额外的文件
- 自动识别和输入验证码
- 提高了单线程下的运行速度

## 环境

**Python**：Python3(Python2需要做些修改)

**网络**：学校内网

如果是外网的话需要换个地址 https://zfw.xidian.edu.cn/


## 依赖

**系统**：推荐在Linux环境下运行（比如说WSL），速度更快，安装也更方便

**Python库**：

```python
import sys
import requests
import pytesseract
import prettytable as pt
from lxml import html
from lxml import etree
from PIL import Image
from io import BytesIO
```

其中，```pytesseract```需要下面的Tesseract才能够正常使用，另外```cssselect```可能需要单独安装

**Tesseract**：

Tesseract 是一个 OCR（Optical Character Recognition，光学字符识别）引擎，能够识别图片中字符

Github 地址：[tesseract-ocr/tesseract](https://github.com/tesseract-ocr/tesseract)

**Linux**：Github上有说明，一般使用系统自带的包管理安装就好

**Windows**：比较麻烦，参考下面的教程设置，主要是环境变量

[Windows安装Tesseract-OCR 4.00并配置环境变量](https://segmentfault.com/a/1190000014086067)

安装完成之后，在命令行键入```tesseract```得到软件提示说明安装成功

## 使用方法

基本的使用就是修改代码中的账户名和密码，然后运行代码即可，效果如下：

![1547570683564](https://img.vim-cn.com/d8/d9116a48cbceb5a05f275ac70a604dc6ad8844.png)

**注**：有时候因为验证码识别失败次数太多，需要重新运行，默认的失败次数阈值下，出现这种情况的概率小于千分之一，平均运行时间在2s左右，如果有其他需求，根据代码提供的接口改下就好

另外，代码里面也提供了可供调节的参数，主要会影响识别的速度，如果要改为多线程运行的话，可以自行修改

## 实现方法

简单的说下原理，主要是模拟流量查询部分的登陆，最为关键的是cookies，另外使用XPath简化匹配

### 对网页登陆的过程分析

#### 工具

这里用的Chrome浏览器的检查功能（F12），之后进入Network选项卡，勾选``preserve log``

![1547567759284](https://img.vim-cn.com/59/a1d5a1eb7e947724e0b5ad4dec3b6547646393.png)

之后正常登陆，就可以看到登陆过程中的request信息，这里在Name一栏，右键勾选Method，再排序，就可以看到登陆时登陆信息（用户名，密码，验证码等）的传输

![1547567836691](https://img.vim-cn.com/b0/f9d652809691fb2c3c5e5b820477aa57a797af.png)

#### 认证

点击第一条（10.255.44.1）可以查看认证时的具体信息

![1547568261535](https://img.vim-cn.com/17/3b592030b26d22534690f7ee4adc6b4f01bc4a.png)

需要关注的

```
Status Code: 302 Found
Set-Cookie: PHPSESSID=88p2tig9au6or3ao250vo7j7o4; path=/; HttpOnly
Location: http://10.255.44.1:8800/home
```

第一条指的是HTTP状态码中的重定向（302 Move temporarily），接收到这条状态码才是认证成功，第二条是post信息被接受后，服务器发来的cookies，用于之后的认证，第三行就是重定向的目标地址

拉倒底部，可以看到POST的信息：Form Data

```
_csrf: Rk51ek8uenEcBA0UI2ocKxx5EkwobUMzCBctIx5UFAEVPTYpfn0tHQ==
LoginForm[username]: ^_^
LoginForm[password]: ^_^
LoginForm[verifyCode]: 7170
login-button:
```

第一行是动态变化的字符串，和POST时使用的cookies一同来自于登陆认证网站，具体看cookies一栏

```
Request Cookies							
PHPSESSID	k96l966erevuaidlgilu8neok1
_csrf	534478b589686f81bb22e1fa533f2d7ab088fe47

Response Cookies				
PHPSESSID	88p2tig9au6or3ao250vo7j7o4

```

使用第一个Cookies实现了Request POST认证，而Response又返回了一个Cookies，这个Cookies很关键

#### 流量查询

上面的一步仅仅是完成了认证和跳转链接，那么到了流量查询网站又是怎么实现登陆的

查看检查工具的第二条（home）

Headers部分：

```HTML
Request URL: http://10.255.44.1:8800/home
Request Method: GET
Status Code: 200 OK
```

可以看到这里是向流量查询的URL发送了一个GET请求

Cookies部分：

```html
Request Cookies						
PHPSESSID	88p2tig9au6or3ao250vo7j7o4		
_csrf	534478b589686f81bb22e1fa533f2d7ab088fe47				
```

这里的Cookies就是上面认证后返回的Cookies，所以这就是“认证——跳转——登陆”的关键了

### 使用XPath获取内容

同样是使用检查工具，相比于正则表达式和BeautifulSoup，对于这种看起来就不好解析的部分，用XPath还是又速度上的优势的，这里爬取的是整个表格，对于XPath也可以找到规律

![1547569903946](https://img.vim-cn.com/95/01fe0b266425b36d96035c69a251ccdeb689d0.png)

### 测试与优化
主要就是验证码部分，这里使用的Ocr引擎识别普通的打印文本成功率还是很高的，因为学校的验证码只有数字，并且只是简单的对数字做平移和旋转处理，而且对验证码url的页面刷新之后，验证码数值不会变，但是会有处理，所以部分情况下可以直接用Ocr识别出来，这里采用的检验方法就是POST之后，如果登陆失败就重新识别，5k次识别的结果如下
[Frequency]https://img.vim-cn.com/d6/4036f263f42047fdebef8a691388097110679a.png)
而在Linux下，识别加上解析一次需要大约0.6s，测试中最坏的情况需要10s以上，并且概率也不是那么小，所以为了体验还是要优化一下的，一种是用多线程，另外一种就是对需要的识别次数较多的情况直接更换验证码，我的参数就是大概设置了个值，差不多普遍比较快就行了，具体这个还是可以讨论下，毕竟图像的识别率还是有限的。

## 代码

这里只贴上写这篇文章的代码，具体如果之后有更新，详见个人的Github...，
另外还有一个多线程带监测运行情况的代码，因为再windows下的速度不太理想，所以就没有细写了，感兴趣可以提issue

```python
import sys
import requests
import pytesseract
import prettytable as pt
from lxml import html
from lxml import etree
from PIL import Image
from io import BytesIO

#在这里输入用户名和密码
#下面预置的部分用于测试效果
USERNAME = "请输入用户名"
PASSOWORD = "密码"

MAX_login_times=10
MAX_warning_times=5
MAX_post_times=4
agent=r'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36'
headers = {
    "Host": "10.255.44.1:8800",
    "Referer": r"http://10.255.44.1:8800/login",
    'User-Agent': agent
}

BASE_URL = "http://10.255.44.1:8800"
LOGIN_URL = "/login"
HOME_URL = "/home"

POST_url = BASE_URL + LOGIN_URL
GET_url = BASE_URL + HOME_URL

def login_init():
    login_page = requests.get(BASE_URL, allow_redirects=False,timeout = 5)
    #get_login_cookies
    cookies_login=login_page.cookies
    doc_login = html.document_fromstring(login_page.text)
    #get_csrf
    csrf = doc_login.cssselect('input[name="_csrf"]')[0].get('value')
    #get_captcha
    captcha_link = doc_login.cssselect('form img')[0].get('src')
    img_url = BASE_URL + captcha_link
    return cookies_login,csrf,img_url

def get_captcha_string(cookies_login,img_url):
    #get_captcha_string by pytesseract and BytesIO
    img_get = requests.get(img_url,cookies=cookies_login,headers = headers)
    img_binary = img_get.content
    captcha_img=Image.open(BytesIO(img_binary))
    captcha_string = pytesseract.image_to_string(captcha_img)
    return captcha_string

def login_try():
    cookies_login,csrf,img_url=login_init()
    for trid_times in range(MAX_post_times):
        captcha_string=get_captcha_string(cookies_login,img_url)
        post_data = {
                "_csrf": csrf,
                "LoginForm[username]": USERNAME,
                "LoginForm[password]": PASSOWORD,
                "LoginForm[verifyCode]": captcha_string,
                }
        login_result = requests.post(POST_url, data=post_data, cookies=cookies_login,headers = headers, allow_redirects=False,timeout = 15)
        login_status_code = login_result.status_code
        if login_status_code == 302 :
            cookies_home=login_result.cookies
            break
    return cookies_home

def home_parse(cookies_home):
    home_page = requests.get(GET_url, cookies=cookies_home)
    dom = etree.HTML(home_page.text)
    thead=[]
    tbody=[]
    for i in range(1,6):
        thead_xpath='//*[@id="w3-container"]/table/thead/tr/th['+str(i)+']/text()'
        tbody_xpath='//*[@id="w3-container"]/table/tbody/tr/td['+str(i)+']/text()'
        thead.append(dom.xpath(thead_xpath)[0])
        tbody.append(dom.xpath(tbody_xpath)[0])
    tb = pt.PrettyTable()
    tb.field_names = thead
    tb.add_row(tbody)
    tb.set_style(pt.PLAIN_COLUMNS)
    print(tb)

def hint():
    if MAX_warning_times==0:
        print("用户名、密码可能有误")
        print("然而脚本会继续运行，如长时间没有输出，则判定为登陆超时")
    if MAX_warning_times==0:
        print("登陆超时")
        print("请自行检查")
        sys.exit(0)

if __name__ == '__main__':
    print("用户名: %s "%USERNAME)
    while True:
        try:
            MAX_login_times=MAX_login_times-1
            MAX_warning_times=MAX_warning_times-1
            cookies_home=login_try()
            home_parse(cookies_home)
            break
        except:
            hint()
```
